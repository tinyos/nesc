% Not in ref manual (implementation restriction rather than language feature):
%   no initialisers on module variables (future support)
%   (but vars w/ attribute C are not module vars)

\documentclass[11pt]{article}

\usepackage{fullpage}
\usepackage{xspace}

\newcommand{\kw}[1]{{\tt #1}}
\newcommand{\code}[1]{{\tt #1}}
\newcommand{\file}[1]{{\tt #1}}
\newcommand{\nesc}{nesC\xspace}
\newcommand{\opt}{$_\mbox{opt}$\xspace}
\newcommand{\FSE}{\mathcal{F}}
\newcommand{\connect}{\mathcal{C}}

\parskip 0.15cm
\parindent 0cm

\begin{document}

\title{\nesc Language Reference Manual}
\author{David Gay, David Culler, Philip Levis}
\date{September 2002}

\maketitle

\section{Introduction}

\nesc is an extension to C~\cite{kandr} designed to embody the structuring
concepts and execution model of TinyOS~\cite{tinyos}. TinyOS is an
event-driven operating system designed for sensor network nodes that have
very limited resources (e.g., 8K bytes of program memory, 512 bytes of
RAM). TinyOS has been reimplemented in \nesc.

The basic concepts behind \nesc are:
\begin{itemize}
\item Separation of construction and composition: programs are built out of
\emph{components}, which are assembled (``wired'') to form whole
programs. Components define two scopes, one for their specification
(containing the names of their \emph{interface instances}) and one for
their implementation. Components have internal concurrency in the form of
\emph{tasks}. Threads of control may pass into a component through its
interfaces. These threads are rooted either in a task or a hardware
interrupt.

\item Specification of component behaviour in terms of set of
\emph{interfaces}. Interfaces may be provided or used by the component. The
provided interfaces are intended to represent the functionality that the
component provides to its user, the used interfaces represent the
functionality the component needs to perform its job.

\item Interfaces are bidirectional: they specify a set of functions to be
implemented by the interface's provider (\emph{commands}) and a set to be
implemented by the interface's user (\emph{events}). This allows a single
interface to represent a complex interaction between components (e.g.,
registration of interest in some event, followed by a callback when
that event happens). This is critical because all lengthy commands in
TinyOS (e.g. send packet) are non-blocking; their completion is
signaled through an event (send done). By specifying interfaces, a
component cannot call the \code{send} command unless it provides an
implementation of the \code{sendDone} event.

Typically commands call downwards, i.e., from application components to
those closer to the hardware, while events call upwards. Certain primitive
events are bound to hardware interrupts (the nature of this binding is
system-dependent, so is not described further in this reference manual).

\item Components are statically linked to each other via their interfaces.
This increases runtime efficiency, encourages rubust design, and allows for
better static analysis of program's.

\item \nesc is designed under the expectation that code will be generated
by whole-program compilers. This should also allow for better code 
generation and analysis.
\end{itemize}

This document is a reference manual for \nesc rather than a tutorial. The
TinyOS tutorial\footnote{Available with the TinyOS distribution at
http://webs.cs.berkeley.edu} presents a gentler introduction to \nesc.

The rest of this document is structured as follows:
Section~\ref{sec:notation} presents the notation used in the reference
manual. Sections~\ref{sec:interface},~\ref{sec:component},~\ref{sec:module},
and~\ref{sec:configuration} present \nesc interfaces and
components. Section~\ref{sec:app} explains how C files, \nesc interfaces
and components are assembled into an application. Section~\ref{sec:misc}
covers the remaining miscellaneous features of \nesc. Finally,
Appendix~\ref{sec:grammar} fully defines \nesc's grammar (as an extension to
the C grammar from Appendix~A of Kernighan and Ritchie (K\&R)
~\cite[pp234--239]{kandr}), and Appendix~\ref{sec:glossary} is a glossary
of the terms used in this reference manual.

\section{Notation}
\label{sec:notation}

The \texttt{typewriter} font is used for \nesc code and for
filenames. Single symbols in italics, with optional subscripts, are used to
refer to \nesc entities, e.g., ``component $K$'' or ``value $v$''.

The grammar of \nesc is an extension the ANSI C grammar. We chose to base
our presentation on the ANSI C grammar from Appendix~A of Kernighan and
Ritchie (K\&R) ~\cite[pp234--239]{kandr}. We will not repeat productions
from that grammar here. Words in \emph{italics} are non-terminals and
non-literal terminals, \kw{typewriter} words and symbols are literal
terminals. The subscript \emph{opt} indicates optional terminals or
non-terminals. In some cases, we change some ANSI C grammar rules. We
indicate this as follows: \emph{also} indicates additional productions for
existing non-terminals, \emph{replaced by} indicates replacement of an
existing non-terminal. 

Explanations of \nesc constructs are presented along with the corresponding
grammar fragments. In these fragments, we sometimes use \ldots to represent
elided productions (irrelevant to the construct at
hand). Appendix~\ref{sec:grammar} presents the full \nesc grammar.

Several examples use the \code{uint8\_t} and \code{uint16\_t} types from
the C99 standard \file{inttypes.h} file.

\section{Interfaces}
\label{sec:interface}

Interfaces in \nesc are bidirectional: they specify a multi-function
interaction channel between two components, the \emph{provider} and the
\emph{user}. The interface specifies a set of named functions, called
\emph{commands}, to be implemented by the interface's provider and a set of
named functions, called \emph{events}, to be implemented by the interface's
user.

This section explains how interfaces are specified,
Section~\ref{sec:component} explains how components specify the interfaces
they provide and use, Section~\ref{sec:module} explains how commands and
events are called from and implemented in C code and
Section~\ref{sec:configuration} explains how component interfaces are
linked together.

Interfaces are specified by \emph{interface types}, as follows:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
nesC-file: \\
\>	includes-list\opt interface\\
\>	\ldots\\
\\
interface:\\
\>	\kw{interface} identifier \kw{\{} declaration-list \kw{\}}\\
\\
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event}\\
\end{tabbing}}
This declares interface type \emph{identifier}. This identifier has global
scope and belongs to a separate namespace, the \emph{component and
interface type} namespace. So all interface types have names distinct from
each other and from all components, but there can be no conflicts with
regular C declarations.

Each interface type has a separate scope for the declarations in
\emph{declaration-list}. This \emph{declaration-list} must consist of
function declarations with the \kw{command} or \kw{event} storage class (if
not, a compile-time error occurs).

An interface can optionally include C files via the \emph{includes-list}
(see Section~\ref{sec:app}).

A simple interface is:
\begin{verbatim}
interface SendMsg { 
  command result_t send(uint16_t address, uint8_t length, TOS_MsgPtr msg);
  event result_t sendDone(TOS_MsgPtr msg, result_t success);
}
\end{verbatim}

Provides of the \code{SendMsg} interface type must implement the
\code{send} command, while users must implement the \code{sendDone} event.

\section{Component Specification}
\label{sec:component}

A \nesc component is either a \emph{module} (Section~\ref{sec:module}) or a
\emph{configuration} (Section~\ref{sec:configuration}):
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
nesC-file: \\
\>	includes-list\opt module\\
\>	includes-list\opt configuration\\
\>	\ldots\\
\\
module:\\
\>	\kw{module} identifier specification module-implementation\\
\\
configuration:\\
\>	\kw{configuration} identifier specification configuration-implementation\\
\end{tabbing}}
Component's names are specified by the \emph{identifier}. This identifier
has global scope and belongs to the component and interface type namespace.
A component introduces two per-component scopes: a specification scope,
nested in the C global scope, and an implementation scope nested in the
specification scope.

A component can optionally include C files via the \emph{includes-list}
(see Section~\ref{sec:app}).

The \emph{specification} lists the \emph{specification elements} (interface
instances, commands or events) \emph{used} or \emph{provided} by this
component. As we saw in Section~\ref{sec:interface}, a component must
implement the commands of its provided interfaces and the events of its
used interfaces. Additionally, it must implement its provided commands and
events.

Typically, commands ``call down'' towards the hardware components and
events ``call up'' towards application components (this assumes a view of
\nesc applications as a graph of components with application components on
top). A thread of control crosses components only though its specification
elements.

Each specification element has a name (interface instance name, command
name or event name). These names belong to the variable namespace of the
per-component-specification scope.  \emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
specification:\\
\>	\kw{\{} uses-provides-list \kw{\}}\\
\\
uses-provides-list:\\
\>	uses-provides\\
\>	uses-provides-list uses-provides\\
\\
uses-provides:\\
\>	\kw{uses} specification-element-list\\
\>	\kw{provides} specification-element-list\\
\\
specification-element-list:\\
\>	specification-element\\
\>	\kw{\{} specification-elements \kw{\}}\\
\\
specification-elements:\\
\>	specification-element\\
\>	specification-elements specification-element\\
\end{tabbing}}
There can be multiple \kw{uses} and \kw{provides} directives in a component
specification. Multiple used or provided specification elements can be
grouped in a single directive by surrounding them with \{ and \}. For
instance, the following two specifications are identical:

\begin{minipage}[t]{3in}
\begin{verbatim}
module A1 {
  uses interface X;
  uses interface Y;
} ...
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{3in}
\begin{verbatim}
module A1 {
  uses {
    interface X;
    interface Y;
  }
} ...
\end{verbatim}
\end{minipage}

An interface instance is specified as follows:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
specification-element:\\
\>	\kw{interface} renamed-identifier parameters\opt\\
\>	\ldots\\
\\
renamed-identifier:\\
\>	identifier\\
\>	identifier \kw{as} identifier\\
\\
interface-parameters:\\
\>	\kw{[} parameter-type-list \kw{]}
\end{tabbing}}

The complete syntax for interface instance declaration is \code{interface X
as Y}, explicitly specifying \code{Y} as the instance's name. The
\code{interface X} syntax is a shorthand for \code{interface X as X}.

If the \emph{interface-parameters} are omitted, then \code{interface X as
Y} declares a \emph{simple interface instance}, corresponding to a single
interface to this component. If the \emph{interface-parameters} are present
(e.g., \code{interface SendMsg S[uint8\_t id]}) then this is a declaration
of a \emph{parameterised interface instance}, corresponding to multiple
interfaces to this component, one for each distinct tuple of parameter
values (so \code{interface SendMsg S[uint8\_t id]} declares 256 interfaces
of type \code{SendMsg}). The types of the \emph{parameters} must be
integral types (\kw{enum}s are not allowed at this time).

Commands or events can be included directly as specification elements by
including a standard C function declaration with
\kw{command} or \kw{event} as its storage class specifier:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
specification-element:\\
\>	declaration\\
\>	\ldots\\
\\
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event}\\
\end{tabbing}}
It is a compile-time error if the \emph{declaration} is not a function
declaration with the \kw{command} or \kw{event} storage class. 

As with interface instances, commands (events) are \emph{simple commands}
(\emph{simple events}) if no interface parameters are specified, or
\emph{parameterised commands} (\emph{parameterised events}) if interface
parameters are specified. The \emph{interface-parameters} are placed before
the function's regular parameter list, e.g., \code{command void
send[uint8\_t id](int x)}: \emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
direct-declarator: \emph{also}\\
\>	direct-declarator interface-parameters \kw{(} parameter-type-list \kw{)}\\
\>	\ldots
\end{tabbing}}
Note that interface parameters are only allowed on commands or events within
component specifications, not within interface types.

Here is a full specification example:
\begin{verbatim}
configuration GenericComm {
  provides {
    interface StdControl as Control;
    interface SendVarLenPacket;
    
    // The interface are parameterised by the active message id
    interface SendMsg[uint8_t id];
    interface ReceiveMsg[uint8_t id];
  }
  uses {
    // signaled after every send completion for components which wish to
    // retry failed sends
    event result_t sendDone();
  }
} ...
\end{verbatim}
In this example, \code{GenericComm}:
\begin{itemize}
\item Provides simple interface instance \code{Control} of type
\code{StdControl}.
\item Provides simple interface instance \code{SendVarLenPacket} of type
\code{SendVarLenPacket}.
\item Provides parameterised instances of interface type \code{SendMsg} and
\code{ReceiveMsg}; the parameterised instances are named \code{SendMsg} and
\code{ReceiveMsg} respectively.
\item Uses event \code{sendDone}.
\end{itemize}

We say that a command (event) $F$ provided in the specification of
component $K$ is \emph{provided command (event)} $F$ of $K$; similarly, a
command (event) used in the specification of component $K$ is \emph{used
command (event)} $F$ of $K$.

A command $F$ in a provided interface instance $X$ of component $K$ is
provided command $X.F$ of $K$; a command $F$ in a used interface instance
$X$ of $K$ is used command $X.F$ of $K$; an event $F$ in a provided
interface instance $X$ of $K$ is used event $X.F$ of $K$; and an event $F$
in a used interface instance $X$ of $K$ is provided event $X.F$ of $K$
(note the reversal of used and provided for events due to the bidirectional
nature of interfaces). 

We will often simply refer to the ``command or event $\alpha$ of $K$'' when
the used/provided distinction is not relevant.  Commands or events $\alpha$
of $K$ may be parameterised or simple, depending on the parameterised or
simple status of the specification element to which they correspond.

\section{Modules}
\label{sec:module}

Modules implement a component specification with C code:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
module-implementation:\\
\>	\kw{implementation} \kw{\{} translation-unit \kw{\}}\\
\end{tabbing}}
where \emph{translation-unit} is a list of C declarations and definitions
(see K\&R~\cite[pp234--239]{kandr}). 

The top-level declarations of the module's \emph{translation-unit} belong
to the module's component-implementation scope. These declarations have
indefinite extent and can be: any standard C declaration or definition, a
TinyOS task declaration or definition, a commands or event
implementation.

\subsection{Implementing the Module's Specification}

The \emph{translation-unit} must implement all provided commands
(events) $\alpha$ of the module (i.e., all directly provided commands and
events, all commands in provided interfaces and all events in used
interfaces). A module can call any of its commands and signal any of its
events.

These command and event implementations are specified with the following C
syntax extensions:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event}\\
\\
declaration-specifiers: \emph{also}\\
\>	\kw{default} declaration-specifiers\\
\\
direct-declarator: \emph{also}\\
\>	identifier \kw{.} identifier \\
\>	direct-declarator interface-parameters \kw{(} parameter-type-list \kw{)}\\
\end{tabbing}}
The implementation of simple command or event $\alpha$ has the syntax of a C
function definition for $\alpha$ (note the extension to
\emph{direct-declarator} to allow \code{.} in function names) with storage
class \kw{command} or \kw{event}. For example, in a module that provides
interface \code{Send} of type \kw{SendMsg}:
\begin{verbatim}
command result_t Send.send(uint16_t address, uint8_t length, TOS_MsgPtr msg) {
  ...
  return SUCCESS;
}
\end{verbatim}

The implementation of parameterised command or event $\alpha$ with interface
parameters $P$ has the syntax of a C function definition for $\alpha$ with
storage class \kw{command} or \kw{event} where the function's regular
parameter list is prefixed with the parameters $P$ within square brackets
(this is the same syntax as parameterised command or event declarations
within a component specification). These interface parameter declarations
$P$ belong to $\alpha$'s function-parameter scope and have the same extent
as regular function parameters. For example, in a module that provides
interface \code{Send[uint8\_t id]} of type \kw{SendMsg}:
\begin{verbatim}
command result_t Send.send[uint8_t id](uint16_t address, uint8_t length, 
                                       TOS_MsgPtr msg) {
  ...
  return SUCCESS;
}
\end{verbatim}

Compile-time errors are reported when:
\begin{itemize}
\item There is no implementation for a provided command or event.
\item The type signature (and optional interface parameters) of a command or
event does not match that given in the module's specification.
\end{itemize}

\subsection{Calling Commands and Signaling Events}

The following extensions to C syntax are used to call events and signal
commands:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
postfix-expression:\\
\>	postfix-expression \kw{[} argument-expression-list \kw{]}\\
\>	call-kind\opt primary \kw{(} argument-expression-list\opt \kw{)}\\
\>	\ldots
\\\\
call-kind: \emph{one of}\\
\>	\kw{call} \kw{signal} \kw{post}
\end{tabbing}}

A simple command $\alpha$ is called with \code{call $\alpha$(...)}, a
simple event $\alpha$ is signaled with \code{signal $\alpha$(...)}. For
instance, in a module that uses interface \code{Send} of type \kw{SendMsg}:
\code{call Send.send(1, sizeof(Message), &msg1)}.

A parameterised command $\alpha$ (respectively, an event) with $n$
interface parameters of type $\tau_1, \ldots, \tau_n$ is called with
interface parameters expressions $e_1, \ldots, e_n$ as follows: \code{call
$\alpha$[$e_1, \ldots, e_n$](...)}  (respectively, \code{signal
$\alpha$[$e_1, \ldots, e_n$](...)}). Interface parameter expression $e_i$
must be assignable to type $\tau_i$; the actual interface parameter value
is $e_i$ cast to type $\tau_i$. For instance, in a module that uses
interface \code{Send[uint8\_t id]} of type \kw{SendMsg}:

\begin{verbatim}
  int x = ...;
  call Send.send[x + 1](1, sizeof(Message), &msg1);
\end{verbatim}

Execution of commands and events is immediate, i.e., \kw{call} and
\kw{signal} behave similarly to function calls. The actual command or event
implementations executed by a \code{call} or \code{signal} expression
depend on the wiring statements in the program's configurations. These
wiring statements may specify that 0, 1 or more implementations are to be
executed. When more than 1 implementation is executed, we say that the
module's command or event has ``fan-out''.  

A module can specify a default implementation for a used command or event
$\alpha$ that it calls or signals. A compile-time error occurs for default
implementations of provided commands or events. Default implementations are
executed when $\alpha$ is not connected to any command or event
implementation. A default command or event is defined by prefixing a
command or event implementation with the \kw{default} keyword:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
declaration-specifiers: \emph{also}\\
\>	\kw{default} declaration-specifiers\\
\end{tabbing}}
For instance, in a in a module that uses interface \code{Send} of type
\kw{SendMsg}:
\begin{verbatim}
default command result_t Send.send(uint16_t address, uint8_t length, 
                                   TOS_MsgPtr msg) {
  return SUCCESS;
}
/* call is allowed even if interface Send is not connected */
... call Send.send(1, sizeof(Message), &msg1) ...
\end{verbatim}

Section~\ref{sec:wiring-semantics} specifies what command or event
implementations are actually executed and what result gets returned by
\code{call} and \code{signal} expressions.

\subsection{Tasks}

A TinyOS task is an independent locus of control defined by a function of
storage class \kw{task} returning \kw{void} and with no arguments:
\code{task void myTask() \{ ... \}}.\footnote{\nesc functions with no
arguments are declared with \code{()}, not \code{(void)}. See
Section~\ref{sec:misc-void}.} A task can also have a forward declaration, e.g.,
\code{task void myTask();}.

Tasks are posted by prefixing a call to the task with \kw{post}, e.g.,
\code{post myTask()}. Post returns immediately; its return value is 1 if
the task was successfully posted for independent execution, 0
otherwise. The type of a post expression is \code{unsigned char}.
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
storage-class-specifier: \emph{also one of}\\
\>	\kw{task}\\
\\
call-kind: \emph{also one of}\\
\>	\kw{post}
\end{tabbing}}

\section{Configurations}
\label{sec:configuration}

Configurations implement a component specification by connecting, or wiring,
together a collection of other components:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
configuration-implementation:\\
\>	\kw{implementation} \kw{\{} component-list\opt connection-list \kw{\}}\\
\end{tabbing}}

The \emph{component-list} lists the components that are used to build this
configuration, the \emph{connection-list} specifies how these components
are wired to each other and to the configuration's specification.

In the rest of this section, we call specification elements from the
configuration's specification \emph{external},
and specification elements from one of the configuration's components
\emph{internal}.

\subsection{Included components}
\label{sec:config-components}

The \emph{component-list} specifies the components used to build this
configuration. These components can be optionally renamed within the
configuration, either to avoid name conflicts with the configuration's
specification elements, or to simplify changing the components a
configuration uses (to avoid having to change the wiring). The names
chosen for components belong to the component's implementation scope.

\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
component-list:\\
\>	components\\
\>	component-list components\\
\\
components:\\
\>	\kw{components} component-line \kw{;}\\
\\
component-line:\\
\>	renamed-identifier\\
\>	component-line \kw{,} renamed-identifier\\
\\
renamed-identifier:\\
\>	identifier\\
\>	identifier \kw{as} identifier\\
\end{tabbing}}

A compile-time error occurs if two components are given the same name using \kw{as} (e.g., \code{components X, Y as X}).

There is only ever a single instance of a component: if a component $K$
is used in two different configurations (or even twice within the same
configuration) there is still only instance of $K$ (and its variables)
in the program.

\subsection{Wiring}
\label{sec:wiring}

Wiring is used to connect specification elements (interfaces, commands,
events) together. This section and the next (Section~\ref{sec:implicit})
define the syntax and compile-time rules for
wiring. Section~\ref{sec:wiring-semantics} details how a program's wiring
statements dictate which functions get called at each \kw{call} and
\kw{signal} expression.  \emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
connection-list:\\
\>	connection\\
\>	connection-list connection\\
\\
connection:\\
\>	endpoint \kw{=} endpoint\\
\>	endpoint \kw{->} endpoint\\
\>	endpoint \kw{<-} endpoint\\
\\
endpoint:\\
\>	identifier-path \\
\>	identifier-path \kw{[} argument-expression-list \kw{]}\\
\\
identifier-path:\\
\>	identifier\\
\>	identifier-path \kw{.} identifier\\
\end{tabbing}}


Wiring statements connect two \emph{endpoints}. The \emph{identifier-path}
of an \emph{endpoint} specifies a specification element. The
\emph{argument-expression-list} optionally specifies interface parameter
values. We say that an endpoint is parameterised if its specification
element is parameterised and the endpoint has no parameter values. A
compile-time error occurs if an endpoint has parameter values and any of
the following is true:
\begin{itemize}
\item The parameter values are not all constant expressions.
\item The endpoint's specification element is not parameterised.
\item There are more (or less) parameter values than there are parameters
on the specification element.
\item The parameter values are not in range for the specification element's
parameter types.
\end{itemize}

A compile-time error occurs if the \emph{identifier-path} of an
\emph{endpoint} is not of one the three following forms:
\begin{itemize}
\item $X$, where $X$ names an external specification element.
\item $K.X$ where $K$ is a component from the \emph{component-list} and
$X$ is a specification element of $K$.
\item $K$ where $K$ is a some component name from the \emph{component-list}.
This form is used in implicit connections, discussed in
Section~\ref{sec:implicit}. Note that this form cannot be used when
parameter values are specified.
\end{itemize}

There are three wiring statements in \nesc:
\begin{itemize}
\item \emph{endpoint}$_1$ \code{=} \emph{endpoint}$_2$ \ (equate wires):
Any connection involving an external specification element. These
effectively make two specification elements equivalent.

Let $S_1$ be the specification element of \emph{endpoint}$_1$ and $S_2$
that of \emph{endpoint}$_2$. One of the following two conditions must hold
or a compile-time error occurs:
\begin{itemize}
\item $S_1$ is internal, $S_2$ is external (or vice-versa) and $S_1$ and
$S_2$ are both provided or both used,
\item $S_1$ and $S_2$ are both external and one is provided and the other used.
\end{itemize}

\item \emph{endpoint}$_1$ \code{->} \emph{endpoint}$_2$ \ (link wires): A
connection involving two internal specification elements. Link wires always
connect a used specification element specified by \emph{endpoint}$_1$ to a
provided one specified by \emph{endpoint}$_2$ . If these two conditions do
not hold, a compile-time error occurs.

\item \emph{endpoint}$_1$ \code{<-} \emph{endpoint}$_2$ is equivalent to
\emph{endpoint}$_2$ \code{->} \emph{endpoint}$_1$.
\end{itemize}

In all three kinds of wiring, the two specification elements specified must
be compatible, i.e., they must both be commands, or both be events, or both
be interface instances. Also, if they are commands (or events), then they
must both have the same function signature. If they are interface instances
they must be of the same interface type. If these conditions do not hold,
a compile-time error occurs.

If one endpoint is parameterised, the other must be too and must have the
same parameter types; otherwise a compile-time error occurs.

The same specification element may be connected multiple times, e.g.,:
\begin{verbatim}
configuration C {
  provides interface X;
} implementation {
  components C1, C2;

  X = C1.X;
  X = C2.X;
}
\end{verbatim}
In this example, the multiple wiring will lead to multiple signalers
(``fan-in'') for the events in interface \code{X} and for multiple
functions being executed (``fan-out'') when commands in interface \code{X}
are called. Note that multiple wiring can also happen when two
configurations independently wire the same interface, e.g.:
\begin{verbatim}
configuration C { }           configuration D { }
implementation {              implementation {
  components C1, C2;            components C3, C2;

  C1.Y -> C2.Y;                 C3.Y -> C2.Y;
}                             }
\end{verbatim}

All external specification elements must be wired or a compile-time error
occurs. However, internal specification elements may be left unconnected
(these may be wired in another configuration, or they may be left unwired
if the modules have the appropriate \kw{default} event or command
implementations).

\subsection{Implicit Connections}
\label{sec:implicit}

It is possible to write \code{$K_1$ <- $K_2$.$X$} or \code{$K_1$.$X$ <-
$K_2$} (and the same with \kw{=}, or \kw{->}). This syntax iterates through
the specification elements of $K_1$ (resp. $K_2$) to find a specification
element $Y$ such that \code{$K_1$.$Y$ <- $K_2$.$X$} (resp. \code{$K_1$.$X$
<- $K_2$.$Y$}) forms a valid connection. If exactly one such $Y$ can
be found, then the connection is made, otherwise a compile-time error
occurs.

For instance, with:
\begin{verbatim}
module M1 {                              module M2 {
  provides interface StdControl;           uses interface StdControl as SC;
} ...                                    } ...

              configuration C { }
              implementation {
                components M1, M2;
                M2.SC -> M1;
              }
\end{verbatim}
The \code{M2.SC -> M1} line is equivalent to \code{M2.SC -> M1.StdControl}.

\subsection{Wiring Semantics}
\label{sec:wiring-semantics}

We first explain the semantics of wiring in the absence of parameterised
interfaces. Section~\ref{sec:wiring-parms} below covers parameterised
interfaces. Finally, Section~\ref{sec:wiring-reqs} specifies requirements
on the wiring statements of an application when viewed as a whole. We will
use the simple application of Figure~\ref{fig:wiring} as our running
example.

\begin{figure}
\begin{verbatim}
interface X {               module M {
  command int f();            provides interface X as P;
  event void g(int x);        uses interface X as U;
}                             provides command void h();
                            } implementation { ... }
configuration C {
  provides interface X;
  provides command void h2();
}
implementation {
  components M;
  X = M.P;
  M.U -> M.P;
  h2 = M.h;
}  
\end{verbatim}
\caption{Simple Wiring Example}
\label{fig:wiring}
\end{figure}

We define the meaning of wiring in terms of \emph{intermediate
functions}.\footnote{\nesc can be compiled without explicit intermediate
functions, so the behaviour described in this section has no runtime cost
beyond the actual function calls and the runtime dispatch necessary for
parameterised commands or events.}  There is one intermediate function
$I_\alpha$ for every command or event $\alpha$ of every component. For
instance, in Figure~\ref{fig:wiring}, module M has intermediate functions
$I_\code{M.P.f}$, $I_\code{M.P.g}$, $I_\code{M.U.f}$, $I_\code{M.U.g}$,
$I_\code{M.h}$.  In examples, we name intermediate functions based on their
component, optional interface instance name and function name.

An intermediate function is either used or provided. Each intermediate
function takes the same arguments as the corresponding command or event in
the component's specification. The body of an intermediate function $I$ is
a list of calls (executed sequentially) to other intermediate
functions. These other intermediate functions are the functions to which
$I$ is connected by the application's wiring statements. The arguments $I$
receives are passed on to the called intermediate functions unchanged. The
result of $I$ is a list of results (the type of list elements is the result
type of the command or event corresponding to $I$), built by concatenating
the result lists of the called intermediate functions. An intermediate
function which returns an empty result list corresponds to an unconnected
command or event; an intermediate function which returns a list of two or
more elements corresponds to ``fan-out''.

\paragraph{Intermediate Functions and Configurations}

The wiring statements in a configuration specify the body of intermediate
functions. We first expand the wiring statements to refer to intermediate
functions rather than specification elements, and we suppress the
distinction between \code{=} and \code{->} wiring statements. We write
\code{$I_1$ <-> $I_2$} for a connection between intermediate functions
\code{$I_1$} and \code{$I_2$}. For instance, configuration \code{C} from
Figure~\ref{fig:wiring} specifies the following intermediate function
connections:\\
\begin{tabular}{ccc}
$I_\code{C.X.f}$ \code{<->} $I_\code{M.P.f}$ & 
$I_\code{M.U.f}$ \code{<->} $I_\code{M.P.f}$ & 
$I_\code{C.h2}$ \code{<->} $I_\code{M.h}$ \\
$I_\code{C.X.g}$ \code{<->} $I_\code{M.P.g}$ & 
$I_\code{M.U.g}$ \code{<->} $I_\code{M.P.g}$
\end{tabular}

In a connection \code{$I_1$ <-> $I_2$} from a configuration
$C$ one of the two intermediate functions is the \emph{callee} and the
other is the \emph{caller}. The connection simply specifies that a call to
the callee is added to the body of the caller. \code{$I_1$}
(similarly, \code{$I_2$}) is a callee if any of the following conditions hold
(we use the internal, external terminology for specification elements with
respect to the configuration $C$ containing the connection):
\begin{itemize}
\item If \code{$I_1$} corresponds to an internal specification element that
is a provided command or event.
\item If \code{$I_1$} corresponds to an external specification element that
is a used command or event.
\item If \code{$I_1$} corresponds to a command of interface instance $X$,
and $X$ is an internal, provided or external, used specification element.
\item If \code{$I_1$} corresponds to an event of interface instance $X$,
and $X$ is an external, provided or internal, used specification element.
\end{itemize}
If none of these conditions hold, \code{$I_1$} is a caller. The rules for
wiring in Section~\ref{sec:wiring} ensure that a connection \code{$I_1$ <->
$I_2$} cannot connect two callers or two callees. In configuration \code{C}
from Figure~\ref{fig:wiring}, $I_\code{C.X.f}$, $I_\code{C.h2}$,
$I_\code{M.P.g}$, $I_\code{M.U.f}$ are callers and $I_\code{C.X.g}$,
$I_\code{M.P.f}$, $I_\code{M.U.g}$, $I_\code{M.h}$ are callees. Thus the
connections of \code{C} specify that a call to $I_\code{M.P.f}$ is added to
$I_\code{C.X.f}$, a call to $I_\code{C.X.g}$ is added to $I_\code{M.P.g}$,
etc.


\paragraph{Intermediate Functions and Modules}

The C code in modules calls, and is called by, intermediate functions. 

The intermediate function $I$ for provided command or event $\alpha$ of
module $M$ contains a single call to the implementation of $\alpha$ in
$M$. Its result is the singleton list of this call's result.

The expression \code{call} $\alpha(e_1, \ldots, e_n)$ is evaluated as
follows:
\begin{itemize}
\item The arguments $e_1, \ldots, e_n$ are evaluated, giving values $v_1,
\ldots, v_n$.
\item The intermediate function $I$ corresponding to $\alpha$ is called
with arguments $v_1, \ldots, v_n$, with results list $L$.
\item If $L$ has one or more elements, the result of the \code{call} is an
arbitrary element chosen from $L$.
\item If $L$ is empty the default implementation for $\alpha$ is
called with arguments $v_1, \ldots, v_n$, and its result is the result of
the \code{call}. Section~\ref{sec:wiring-reqs} specifies that a
compile-time error occurs if $L$ can be empty and there is no default
implementation for $\alpha$.
\end{itemize}
The rules for \code{signal} expressions are identical.

\paragraph{Example Intermediate Functions} 

Figure~\ref{fig:wiring-fns} shows the intermediate functions that are
produced for the components of Figure~\ref{fig:wiring}, using a C-like
syntax, where \code{list($x$)} produces a singleton list containing $x$,
\code{empty\_list} is a constant for the 0 element list and
\code{concat\_list} concatenates two lists. The calls to \code{M.P.f},
\code{M.U.g}, \code{M.h} represent calls to the command and event
implementations in module \code{M} (not shown).

\begin{figure}
\begin{tabular}{ll}
\tt list of int $I_\code{M.P.f}()$ \{ & \tt list of void $I_\code{M.P.g}$(int x) \{ \\
\tt \ \ return list(M.P.f());         & \tt \ \ list of int r1 = $I_\code{C.X.g}$(x); \\
\tt }                                 & \tt \ \ list of int r1 = $I_\code{M.U.g}$(x); \\
                                      & \tt \ \ return list\_concat(r1, r2); \\
                                      & \tt } \\
\\
\tt list of int $I_\code{M.U.f}()$ \{ & \tt list of void $I_\code{M.U.g}$(int x) \{ \\
\tt \ \ return $I_\code{M.P.f}$();    & \tt \ \ return list(M.U.g(x)); \\
\tt \}                                & \tt \} \\
\\
\tt list of int $I_\code{C.X.f}()$ \{ & \tt list of void $I_\code{C.X.g}$(int x) \{ \\
\tt \ \ return $I_\code{M.P.f}$();    & \tt \ \ return empty\_list; \\
\tt \}                                & \tt \} \\
\\
\tt list of void $I_\code{C.h2}()$ \{ & \tt list of void $I_\code{M.h}$() \{ \\
\tt \ \ return $I_\code{M.h}$();      & \tt \ \ return list(M.h()); \\
\tt \}                                & \tt \} \\
\end{tabular}
\caption{Intermediate Functions for Figure~\ref{fig:wiring}}
\label{fig:wiring-fns}
\end{figure}

\subsubsection{Wiring and Parameterised Functions}
\label{sec:wiring-parms}

If a command or event $\alpha$ of component $K$ is parameterised with
interface parameters of type $\tau_1, \ldots, \tau_n$ then there is an
intermediate function $I_{\alpha,v_1,\ldots,v_n}$ for every distinct tuple
$(v_1:\tau_1, \ldots, v_n:\tau_n)$.

In modules, if intermediate function $I_{v_1, \ldots, v_n}$ corresponds
to parameterised, provided command (or event) $\alpha$ then the call in
$I_{v_1, \ldots, v_n}$ to $\alpha$'s implementation passes values $v_1,
\ldots, v_n$ as the values for $\alpha$'s interface parameters. 

The expression \code{call} $\alpha[e'_1, \ldots, e'_m](e_1, \ldots, e_n)$
is evaluated as follows:
\begin{itemize}
\item The arguments $e_1, \ldots, e_n$ are evaluated, giving values $v_1,
\ldots, v_n$.
\item The arguments $e'_1, \ldots, e'_m$ are evaluated, giving values $v'_1,
\ldots, v'_m$.
\item The $v'_i$ values are cast to type $\tau_i$, where $\tau_i$ is the
type of the $i$th interface parameter of $\alpha$.
\item The intermediate function $I_{v'_1,\ldots,v'_m}$ corresponding to
$\alpha$ is called with arguments $v_1, \ldots, v_n$, with results list
$L$.\footnote{This call typically involves a runtime selection between
several command implementations - this is the only place where intermediate
functions have a runtime cost.}
\item If $L$ has one or more elements, the result of the \code{call} is an
arbitrary element chosen from $L$.
\item If $L$ is empty the default implementation for $\alpha$ is called
with interface parameter values $v'_1, \ldots, v'_m$ and arguments $v_1,
\ldots, v_n$, and its result is the result of the
\code{call}. Section~\ref{sec:wiring-reqs} specifies that a compile-time
error occurs if $L$ can be empty and there is no default implementation for
$\alpha$.
\end{itemize}
The rules for \code{signal} expressions are identical.

There are two cases when an endpoint in a wiring statement refers to a
parameterised specification element:
\begin{itemize}
\item The endpoint specifies parameter values $v_1, \ldots, v_n$. If the
endpoint corresponds to commands or events $\alpha_1, \ldots, \alpha_m$
then the corresponding intermediate functions are
$I_{\alpha_1,v_1,\ldots,v_n}$, \ldots, $I_{\alpha_m,v_1,\ldots,v_n}$ and
wiring behaves as before.
\item The endpoint does not specify parameter values. In this case, both
endpoints in the wiring statement correspond to parameterised specification
elements, with identical interface parameter types $\tau_1, \ldots,
\tau_n$. If one endpoint corresponds to commands or events $\alpha_1,
\ldots, \alpha_m$ and the other to corresponds to commands or events
$\beta_1, \ldots, \beta_m$, then there is a connection $I_{\alpha_i, w_1,
\ldots, w_n}$ \code{<->} $I_{\beta_i, w_1,\ldots, w_n}$ for all $1 \leq i
\leq m$ and all tuples $(w_1:\tau_1, \ldots, w_n:\tau_n)$ (i.e., the
endpoints are connected for all corresponding parameter values).
\end{itemize}

\subsubsection{Application-level Requirements}
\label{sec:wiring-reqs}

There are two requirement that the wiring statements of an application must
satisfy, or a compile-time error occurs:
\begin{itemize}
\item There must be no infinite loop involving only intermediate functions.
\item At every \code{call $\alpha$} (or \code{signal $\alpha$}) expression
in the application's modules:
\begin{itemize}
\item If the call is unparameterised: if the call returns an empty result
list there must be a default implementation of $\alpha$ (the number of
elements in the result list depends only on the wiring).
\item If the call is parameterised: if substituation of any values for the
interface parameters of $\alpha$ returns an empty result list there must be
a default implementation of $\alpha$ (the number of elements in the result
list for a given parameter value tuple depends only on the wiring).

Note that this condition does not consider the expressions used to specify
interface parameter values at the call-site.
\end{itemize}
\end{itemize}

\section{\nesc Applications}
\label{sec:app}

A \nesc application has three parts: a list of C declarations and
definitions, a set of interface types and a set of components. The naming
environment of \nesc applications is structured as follows:
\begin{itemize}
\item An outermost, global scope with three namespaces: a C variable and a
C tag namespace for the C declarations and definitions, and a component and
interface type namespace for the \nesc interface types and components.
\item C declarations and definitions may introduce their own nested scopes
within the global scope, as usual (for function declarations and
definitions, code blocks within functions, etc).

\item Each interface type introduces a scope that holds the interface's
commands or events. This scope is nested in the global scope, therefore
command and event definitions can refer to C types and tags defined in the
global scope.

\item Each component introduces two new scopes. The specification scope,
nested in the global scope, contains a variable namespace which holds the
component's specification elements. The implementation scope, nested in the
specification scope, contains a variable and a tag namespace. 

For configurations, the implementation's scope variable namespace contains
the names by which this component refers to its included components
(Section~\ref{sec:config-components}). For modules, the implementation
scope holds the tasks, C declarations and definitions that form the
module's body. These declarations, etc may introduce their own nested
scopes within the implementation scope (for function bodies, code blocks,
etc). As a result of the scope nesting structure, code in modules has
access to the C declarations and definitions in the global scope, but not
to any declarations or definitions in other components.
\end{itemize}

The C declarations and defintions, interface types and components that form
a \nesc application are determined by an on-demand loading process. The
input to the \nesc compiler is a single component $K$. The \nesc compiler
first loads C file \file{tos} (Section~\ref{sec:load-c}), then loads
component $K$ (Section~\ref{sec:load-component}). The code for the
application is all the code loaded as part of the process of loading these
two files. A \nesc compiler can assume that all calls to functions,
commands or events not marked with the \code{spontaneous} attribute
(Section~\ref{sec:attributes}) occur in the loaded code (i.e., there are no
``invisible'' calls to non-\code{spontaneous} functions).\footnote{For
instance, the current \nesc compiler uses this information to eliminate
unreachable code.}

Part of the process of loading a C file, \nesc component or interface type
involves locating the corresponding source file. The mechanism used to
locate files is outside the scope of this reference manual; for details on
how this works in the current compiler please see the \file{ncc} man page.

\subsection{Loading C file $X$}
\label{sec:load-c}

If $X$ has already been loaded, nothing more is done. Otherwise, file $X$.h
is located and preprocessed. Changes made to C macros (via \code{\#define}
and \code{\#undef}) are visible to all subsequently preprocessed files. The C
declarations and definitions from the preprocessed $X$.h file are entered
into the C global scope, and are therefore visible to all subsequently
processed C files, interface types and components.

\subsection{Loading Component $K$}
\label{sec:load-component}

If $K$ has already been loaded, nothing more is done. Otherwise, file
$X$.nc is located and preprocessed. Changes made to C macros (via
\code{\#define} and \code{\#undef}) are discarded. The preprocessed file is
parsed using the following grammar: \emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
nesC-file: \\
\>	includes-list\opt interface\\
\>	includes-list\opt module\\
\>	includes-list\opt configuration\\
\\
includes-list:\\
\>	includes\\
\>	includes-list includes\\
\\
includes:\\
\>	\kw{includes} identifier-list \kw{;}\\
\end{tabbing}}
If $X$.nc does not define \code{module $K$} or \code{configuration $K$}, a
compile-time error is reported. Otherwise, all C files specified by the
\emph{includes-list} are loaded (Section~\ref{sec:load-c}). Then all
interface types used in the component's specification are loaded
(Section~\ref{sec:load-intf}). Next, the component specification is
processed (Section~\ref{sec:component}). If $K$ is a configuration, all
components specified (Section~\ref{sec:config-components}) by $K$ are
loaded (Section~\ref{sec:load-component}). Finally, $K$'s implementation is
processed (Sections~\ref{sec:module} and~\ref{sec:configuration})..

\subsection{Loading Interface Type $I$}
\label{sec:load-intf}

If $I$ has already been loaded, nothing more is done. Otherwise, file
$X$.nc is located and preprocessed. Changes made to C macros (via
\code{\#define} and \code{\#undef}) are discarded. The preprocessed file is
parsed following the \emph{nesC-file} production above. If $X$.nc does not
define \code{interface $I$} a compile-time error is reported. Otherwise,
all C files specified by the \emph{includes-list} are loaded
(Section~\ref{sec:load-c}). Then $I$'s definition is processed
(Section~\ref{sec:interface}).

As an example of including C files in components or interfaces, interface
type \code{Bar} might include C file \file{BarTypes.h} which defines types
used in \code{Bar}:

\begin{minipage}[t]{3in}
\begin{verbatim}
Bar.nc:
includes BarTypes;
interface Bar {
  command result_t bar(BarType arg1);
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{3in}
\begin{verbatim}
BarTypes.h:
typedef struct {
  int x;
  double y;
} BarType;
\end{verbatim}
\end{minipage}

The definition of interface \code{Bar} can refer to \code{BarType}, as can
any component that uses or provides interface \code{Bar} (interface
\code{Bar}, and hence \file{BarTypes.h}, are loaded before any such
component's specification or implementation are processed).

\section{Miscellaneous}
\label{sec:misc}

\subsection{Functions with no arguments, old-style C declarations}
\label{sec:misc-void}

\nesc functions with no arguments are declared with \code{()}, not
\code{(void)}. The latter syntax reports a compile-time error.

Old-style C declarations (with \code{()}) and function definitions 
(parameters specified after the argument list) are not allowed in
interfaces or components (and cause compile-time errors).

Note that neither of these changes apply to C files (so that existing
\file{.h} files can be used unchanged).

\subsection{// comments}

\nesc allows // comments in C, interface type and component files.

\subsection{Attributes}
\label{sec:attributes}

\nesc uses gcc's\footnote{http://gcc.gnu.org} \kw{\_\_attribute\_\_} syntax
for declaring some properties of functions. These attributes can be placed
either on function definitions or function declarations (after the
parameter list).\footnote{gcc doesn't allow attributes after the parameter
list in function definitions.} The attributes of a function $f$ are the
union of all attributes on all declarations and definitions of $f$.

The attribute syntax in \nesc is:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
init-declarator-list: \emph{also}\\
\>	init-declarator attributes\\
\>	init-declarator-list \kw{,} init-declarator attributes\\
\\
function-definition: \emph{also}\\
\>	declaration-specifiers\opt declarator attributes declaration-list\opt compound-statement\\
\\
attributes:\\
\>	attribute\\
\>	attributes attribute\\
\\
attribute:\\
\>	\kw{\_\_attribute\_\_} \kw{(} \kw{(} attribute-list \kw{)} \kw{)}\\
\\
attribute-list:\\
\>	single-attribute\\
\>	attribute-list \kw{,} single-attribute\\
\\
single-attribute:\\
\>	identifier\\
\>	identifier \kw{(} argument-expression-list \kw{)}\\
\end{tabbing}}

\nesc supports two attributes:
\begin{itemize}
\item \code{C}: This attribute is used for a C declaration or definition
$d$ at the top-level of a module (it is ignored for all other
declarations). It specifies that $d$'s should appear in the global C scope
rather than in the module's per-component-implementation scope. This allows
$d$ to be used (e.g., called if it is a function) from C code.

\item \code{spontaneous}: This attribute can be used on any function
$f$ (in modules or C code). It indicates that there are calls $f$ that
are not visible in the source code. Typically, functions that are
called spontaneously are interrupt handlers, and the C \code{main}
function. Section~\ref{sec:app} discusses how the \nesc compiler
uses the \code{spontaneous} attribute during compilation.
\end{itemize}

Example of attribute use: in file \file{RealMain.td}:
\begin{verbatim}
module RealMain { ... }
implementation {
  int main(int argc, char **argv) __attribute__((C, spontaneous)) {
    ...
  }
}
\end{verbatim}

This example declares that function \code{main} should actually appear
in the C global scope (\code{C}), so that the linker can find it. It
also declares that \code{main} can be called even though there are no
function calls to \code{main} anywhere in the program
(\code{spontaneous}). 

\subsection{Compile-time Constant Functions}

\nesc has a new kind of constant expression: \emph{constant
functions}. These are functions defined within the language which
evaluate to a constant at compile-time.

\nesc currently has one constant function, \code{unique}. More are planned
for the near future.

\code{unsigned int unique(char *identifier)} \\ Returns: if the program
contains $n$ calls to \code{unique} with the same \code{identifier}
string, each calls returns a different unsigned integer in the range
$0 .. n-1$.

The intended use of \code{unique} is for passing a unique integer
to parameterised interface instances, so that a component providing
a parameterised interface can uniquely identify the various components
connected to that interface.

\appendix

\section{Grammar}
\label{sec:grammar}

Please refer to  Appendix~A of Kernighan and Ritchie (K\&R)
~\cite[pp234--239]{kandr} while reading this grammar.

The following keywords are new for \nesc: \kw{as}, \kw{call}, \kw{command},
\kw{components}, \kw{configuration}, \kw{event}, \kw{implementation},
\kw{interface}, \kw{module}, \kw{post}, \kw{provides}, \kw{signal},
\kw{task}, \kw{uses}, \kw{includes}. These \nesc keywords are not reserved
in C files. The corresponding C symbols are accessible in \nesc files by
prefixing them with \kw{\_\_nesc\_}\emph{keyword} (e.g.,
\kw{\_\_nesc\_keyword\_as}).

\nesc reserves all identifiers starting with \kw{\_\_nesc} for internal
use. TinyOS reserves all identifiers starting with \kw{TOS\_} and
\kw{TOSH\_}.

\nesc files follow the \emph{nesC-file} production; \file{.h} files included
via the \kw{includes} directive follow the \emph{translation-unit}
directive from K\&R. 

New rules:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
nesC-file: \\
\>	includes-list\opt interface\\
\>	includes-list\opt module\\
\>	includes-list\opt configuration\\
\\
includes-list:\\
\>	includes\\
\>	includes-list includes\\
\\
includes:\\
\>	\kw{includes} identifier-list \kw{;}\\
\\
interface:\\
\>	\kw{interface} identifier \kw{\{} declaration-list \kw{\}}\\
\\
module:\\
\>	\kw{module} identifier specification module-implementation\\
\\
module-implementation:\\
\>	\kw{implementation} \kw{\{} translation-unit \kw{\}}\\
\\
configuration:\\
\>	\kw{configuration} identifier specification configuration-implementation\\
\\
configuration-implementation:\\
\>	\kw{implementation} \kw{\{} component-list\opt connection-list \kw{\}}\\
\\
component-list:\\
\>	components\\
\>	component-list components\\
\\
components:\\
\>	\kw{components} component-line \kw{;}\\
\\
component-line:\\
\>	renamed-identifier\\
\>	component-line \kw{,} renamed-identifier\\
\\
renamed-identifier:\\
\>	identifier\\
\>	identifier \kw{as} identifier\\
\\
connection-list:\\
\>	connection\\
\>	connection-list connection\\
\\
connection:\\
\>	endpoint \kw{=} endpoint\\
\>	endpoint \kw{->} endpoint\\
\>	endpoint \kw{<-} endpoint\\
\\
endpoint:\\
\>	identifier-path \\
\>	identifier-path \kw{[} argument-expression-list \kw{]}\\
\\
identifier-path:\\
\>	identifier\\
\>	identifier-path \kw{.} identifier\\
\\
specification:\\
\>	\kw{\{} uses-provides-list \kw{\}}\\
\\
uses-provides-list:\\
\>	uses-provides\\
\>	uses-provides-list uses-provides\\
\\
uses-provides:\\
\>	\kw{uses} specification-element-list\\
\>	\kw{provides} specification-element-list\\
\\
specification-element-list:\\
\>	specification-element\\
\>	\kw{\{} specification-elements \kw{\}}\\
\\
specification-elements:\\
\>	specification-element\\
\>	specification-elements specification-element\\
\\
specification-element:\\
\>	declaration\\
\>	\kw{interface} renamed-identifier parameters\opt\\
\\
parameters:\\
\>	\kw{[} parameter-type-list \kw{]}
\end{tabbing}}

Changed rules: 
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event} \kw{task}\\
\\
declaration-specifiers: \emph{also}\\
\>	\kw{default} declaration-specifiers\\
\\
direct-declarator: \emph{also}\\
\>	identifier \kw{.} identifier \\
\>	direct-declarator parameters \kw{(} parameter-type-list \kw{)}\\
\\
init-declarator-list: \emph{also}\\
\>	init-declarator attributes\\
\>	init-declarator-list \kw{,} init-declarator attributes\\
\\
function-definition: \emph{also}\\
\>	declaration-specifiers\opt declarator attributes declaration-list\opt compound-statement\\
\\
attributes:\\
\>	attribute\\
\>	attributes attribute\\
\\
attribute:\\
\>	\kw{\_\_attribute\_\_} \kw{(} \kw{(} attribute-list \kw{)} \kw{)}\\
\\
attribute-list:\\
\>	single-attribute\\
\>	attribute-list \kw{,} single-attribute\\
\\
single-attribute:\\
\>	identifier\\
\>	identifier \kw{(} argument-expression-list \kw{)}\\
\\
postfix-expression: \emph{replaced by}\\
\>	primary-expression\\
\>	postfix-expression \kw{[} argument-expression-list \kw{]}\\
\>	call-kind\opt primary \kw{(} argument-expression-list\opt \kw{)}\\
\>	postfix-expression \kw{.} identifier\\
\>	postfix-expression \kw{->} identifier\\
\>	postfix-expression \kw{++}\\
\>	postfix-expression \kw{--}\\
\\\\
call-kind: \emph{one of}\\
\>	\kw{call} \kw{signal} \kw{post}
\end{tabbing}}

\section{Glossary}
\label{sec:glossary}

\begin{itemize}

\item \emph{command}, \emph{event}: A function that is part of a
component's \emph{specification}, either directly as a \emph{specification
element} or within one of the component's \emph{interface instances}.

When used directly as specification elements, commands and events have
roles (\emph{provider}, \emph{user}) and can have \emph{interface
parameters}. As with interface instances, we distinguish between
\emph{simple commands (events)} without interface parameters and
\emph{parameterised commands (events)} with interface parameters. The
interface parameters of a command or event are distinct from its regular
function parameters.

\item \emph{compile-time error}: An error that the \nesc compiler must
report at compile-time.

\item \emph{component}: The basic unit of \nesc programs. Components have a
name and are of two kinds: \emph{modules} and \emph{configurations}. A
component has a \emph{specification} and an implementation. 

\item \emph{configuration}: A component whose implementation is provided
by a composition of other components with a specific \emph{wiring}.

\item \emph{endpoint}: A specification of a particular specification
element, and optionally some interface parameter values, in a wiring
statement of a configuration. A parameterised endpoint is an endpoint
without parameter values that corresponds to a parameterised specification
element.

\item \emph{event}: See command.

\item \emph{extent}: The lifetime of a variable. \nesc has the standard C
extents: \emph{indefinite}, \emph{function}, and \emph{block}.

\item \emph{external}: In a configuration $C$, describes a specification
element from $C$'s specification. See internal.

\item \emph{fan-in}: Describes a provided command or event called from more
than one place.

\item \emph{fan-out}: Describes a used command or event connected to more
than one command or event implementation.

\item \emph{interface}: When the context is unambiguous, we use interface
to refer to either an \emph{interface type} or an \emph{interface instance}.

\item \emph{interface instance}: An instance of a particular
\emph{interface type} in the \emph{specification} of a component. An
interface instance has an instance name, a role (\emph{provider} or
\emph{user}), an \emph{interface type} and, optionally, \emph{interface
parameters}. An interface instance without parameters is a \emph{simple
interface instance}, with parameters it is a \emph{parameterised interface
instance}.

\item \emph{interface parameter}: An interface parameter has an interface
parameter name and must be of integral type. 

There is (conceptually) a separate \emph{simple interface instance} for
each distinct list of parameter values of a \emph{parameterised interface
instance} (and, similarly, separate simple commands or events in the case
of parameterised commands or events). Parameterised interface instances
allow runtime selection based on parameter values between a set of commands
(or between a set of events).

\item \emph{interface type}: An \emph{interface type} specifies the
interaction between two components, \emph{the provider} and the
\emph{user}. This specification takes the form of a set of \emph{commands}
and \emph{events}. Each interface type has a distinct name. 

Interfaces are bi-directional: the provider of an interface implements its
commands, the user of an interface implements its events.

\item \emph{intermediate function}: A pseudo-function that represents the
behaviour of the commands and events of a component, as specified by the
wiring statements of the whole application. See
Section~\ref{sec:wiring-semantics}.

\item \emph{internal}: In a configuration $C$, describes a specification
element from one of the components specified in $C$'s component list. See
external.

\item \emph{module}: A component whose implementation is provided by C
code. 

\item \emph{namespace}: \nesc has the standard C \emph{variable} (also
used for functions and \code{typedef}s), \emph{tagged type} (\code{struct},
\code{union} and \code{enum} tag names) and \emph{label}
namespaces. Additionally, \nesc has a \emph{component and interface type}
namespace for component and interface type names.

\emph{parameterised command, parameterised event, parameterised interface
instance, endpoint}: See command, event, interface instance, endpoint.

\emph{provided, provider}: A role for a specification element. Providers of
\emph{interface instances} must implement the \emph{commands} in the
interface; provided commands and events must be implemented.

\emph{provided command of $K$}: A command that is either a
provided specification element of $K$, or a command of a provided interface
of $K$.

\emph{provided event of $K$}: An event that is either a
provided specification element of $K$, or an event of a used interface
of $K$.

\item \emph{scope}: \nesc has the standard C \emph{global},
\emph{function-parameter} and \emph{block} scopes. Additionally there are
\emph{specification} and \emph{implementation} scopes in components and a
per-interface-type scope. Scopes are divided into namespaces.

\emph{simple command, simple event, simple interface instance}: See
command, event, interface instance.

\item \emph{specification}: A list of \emph{specification elements} that
specifies the interaction of a component with other components.

\item \emph{specification element}: An \emph{interface instance},
\emph{command} or \emph{event} in a specification that is either 
\emph{provided} or \emph{used}.

\item \emph{task}: A TinyOS task.

\emph{used, user}: A role for a specification element. Users of
\emph{interface instances} must implement the \emph{events} in the
interface.

\emph{used command of $K$}: A command that is either a used specification
element of $K$, or a command of a used interface of $K$.

\emph{used event of $K$}: An event that is either a used specification
element of $K$, or an event of a provided interface of $K$.

\item \emph{wiring}: The connections between component's specification
elements specified by a configuration.

\end{itemize}


\bibliographystyle{abbrv}
\bibliography{ref}

\end{document}
